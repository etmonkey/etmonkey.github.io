[{"title":"一种计算平方根近似值的快速算法","url":"/2023/11/04/一种计算平方根近似值的快速算法/","content":"## 缘起\n之所以会写这篇文章，一切缘起与数年前看到的一个大学老师的博文，介绍了卡马克开源的雷神之锤游戏源码，其底层用到的一个求平方根倒数的神奇的算法，这个算法使用牛顿法求解平方根倒数，但只需要1次迭代就能达到很高的精度，如果迭代两次，则计算精度更高。该算法的神奇之处就在于在执行牛顿法迭代之前对自变量进行了一次移位，并与一个魔法常数（magic number）做和，这样就能得到这个自变量平方根倒数的近似值，用这个近似值作为初值，再进一步做牛顿法迭代，就能迅速算出所求的因变量。该算法的代码如下：<br>\n```c\nfloat InvSqrt(float x)\n{\n    float xhalf = 0.5f*x;\n    int i = *(int*)&x;\n    i = 0x5f3759df - (i>>1);\n    x = *(float*)&i;\n    x = x*(1.5f-xhalf*x*x);\n    return x;\n}\n```\n初见这段代码，我是一脸蒙圈，实测后发现这代码确实好使，更是令我不可思议，正好那位大学老师的博文留下了解释这一算法的线索，是一篇老外的论文，论文的链接[在这](https://www.lomont.org/papers/2003/InvSqrt.pdf)。看完论文，我大概明白了这个算法的原理，然后脑子里冒出了一个想法：我是否可以把这个算法推广到用于计算平方根？甚至更进一步，能否推广到用来计算立方根和立方根的倒数？我的这篇文章就介绍了我用这个算法的原理推导出的计算平方根的方法，至于立方根和立方根的倒数的计算，根据我的一些不成熟的推导和测试，用同样的方法似乎无法完成，但根据我初步的计算，4次根号，以及更进一步，2<sup>n</sup>次根号的计算方法则是可以用相同的原理推导出来的。<br>\n之前在网上粗粗搜索了一下，似乎还没有人做这项工作，倒是有人用InvSqrt函数计算出$1/\\sqrt{x}$，然后求倒数得到$\\sqrt{x}$，这样的计算方法和直接通过魔法常数加牛顿法计算$\\sqrt{x}$相比，其精度和速度如何还有待测试。所以我决定干一票，自己把直接计算$\\sqrt{x}$的算法推导出来，不管是否有人已经做过这事，我就当练练手吧。<br>\n\n## 计算$\\sqrt{x}$牛顿法初值的公式\n在计算$1/\\sqrt{x}$的代码中，计算初值的关键代码是这句：\n```c\ni = 0x5f3759df - (i>>1);\n```\n根据论文给出的推导魔法常数的公式，如果仍然使用将魔法常数减去i的移位的方式计算$\\sqrt{x}$的初值，则在计算初值与真值的相对误差时，会出现有一个变量d无法约去的情况，这时的相对误差公式如下：\n$$\\epsilon=\\vert \\frac{\\sqrt{1+M}2^{d+1/2}-(2+\\beta)2^{R_1-192-d}}{\\sqrt{1+M}2^{d+1/2}} \\vert$$\n其中$M$是变量$i$的0\\~22位代表的尾数值，$M\\in[0,1)$，$E$是$i$的23\\~30位代表的指数值，$E\\in[1,254]$，假设此时$E$是个偶数，则有$E-127=2d+1$，$d$是个整数，$R_1$是魔法常数的23\\~30位，$R_2$是魔法常数0\\~22位，$\\beta$是与$R_2$和$M$相关的一个变量。此时$d$无法约去，可以预见到$\\epsilon$的值将会很大。<br>\n此时观察到公式分子的后一项有一个$2^{-d}$，而如果将代码改为\n```c\ni = magic_num + (i>>1);\n```\n则公式中$2^{-d}$将变为$2^{d}$，正好可以约去$d$，于是尝试用上式作为计算$\\sqrt{x}$初值的公式，并推导其魔法常数。<br>\n\n## 算法\n我们要求的是$y=\\sqrt{x}$的值，可定义$f(y)=y^2-x$，根据牛顿法公式：<br>\n$$y_{n+1}=y_n-\\frac{f(y_n)}{f'(y_n)}$$\n得到$y_{n+1}=\\frac{1}{2}(y_n+xy^{-1}_n)$<br>\n\n## 推导魔法常数\n假设待计算的变量x按位序由$0-E-M$组成，则$x=(1+M)2^{E-127}$，且所求的值$y=\\sqrt{x}=\\sqrt{1+M}2^{\\frac{E-127}{2}}$。设魔法常数$R$按位序由$0-R_1-R_2$组成。其中0占最高位31位，表示该数是个正数，$E$和$R_1$占23-30位，$M$和$R_2$占0-22位。<br>\n\n### 推导$R_1$的值\n#### 当E是一个偶数\n则$\\lfloor E/2 \\rfloor=E/2$，令$e=E-127$，而$e=E-127$是奇数，令$e=2d+1$，$d$是一个整数，则初值$y_0$的指数部分为：<br>\n$$\\begin{align}\n    R_1+\\lfloor E/2 \\rfloor&=R_1+E/2 \\nonumber\\\\\n    &=R_1+\\frac{e+127}{2} \\nonumber\\\\\n    &=R_1+\\frac{2d+1+127}{2} \\nonumber\\\\\n    &=R_1+d+64 \\nonumber\n\\end{align}$$\n因为$E$是偶数，$i$右移1位后没有值从指数部分移动到尾数部分，所以新的尾数值是<br>\n$$R_2+\\lfloor M/2 \\rfloor=R_2+M/2$$\n当$R_2+M/2<1$，$R$与$i$相加后尾数部分不对指数部分产生进位，则有<br>\n$$\\begin{align}\n    y_0&=(1+R_2+\\lfloor M/2 \\rfloor)2^{R_1+\\lfloor E/2 \\rfloor-127} \\nonumber\\\\\n    &=(1+R_2+M/2)2^{R_1+d-63} \\nonumber\n\\end{align}$$\n当$R_2+M/2\\geq1$，尾数部分对指数部分产生1位进位，则有<br>\n$$\\begin{align}\n    y_0&=(-1+1+R_2+\\lfloor M/2 \\rfloor)2^{R_1+\\lfloor E/2 \\rfloor-127+1} \\nonumber\\\\\n    &=(2R_2+M)2^{R_1+d-63} \\nonumber\n\\end{align}$$\n其中因为$M$最低位值相对其它误差是很小的，因此可以忽略。令<br>\n$$\\beta=\\begin{cases}\nR_2+M/2 & ,R_2+M/2<1 \\\\\n-1+2R_2+M & ,R_2+M/2\\geq1\n\\end{cases}$$\n则<br>\n$$y_0=(1+\\beta)2^{R_1+d-63}$$\ny的真实值为<br>\n$$y=\\sqrt{1+M}2^{e/2}=\\sqrt{1+M}2^{d+1/2}$$\n则$y_0$和真实值之间的相对误差为：<br>\n$$\\epsilon=\\vert \\frac{y-y_0}{y} \\vert=\\vert \\frac{\\sqrt{1+M}2^{d+1/2}-(1+\\beta)2^{R_1+d-63}}{\\sqrt{1+M}2^{d+1/2}} \\vert$$\n化简为$\\vert \\epsilon_0 \\vert$<br>\n$$\\epsilon_0=1-\\frac{1+\\beta}{\\sqrt{1+M}}2^{R_1-63.5}$$\n不妨令$M=0$，则<br>\n$$\\epsilon_0=1-(1+R_2)2^{R_1-63.5}$$\n令$\\vert \\epsilon_0 \\vert<1/8$，得到<br>\n$$63.5+\\log_2{\\frac{7}{8(1+R_2)}}<R_1<63.5+\\log_2{\\frac{9}{8(1+R_2)}}$$\n其中$R_2\\in[0,1)$，则<br>\n$$62.3<R_2<63.6$$\n所以$R_1=63=0x3F$<br>\n\n#### 当E是一个奇数\n类似的，令$e=E-127=2d$，$d$是一个整数，则初值$y_0$的指数部分为：<br>\n$$R_1+\\lfloor E/2 \\rfloor=R_1+d+63$$\n尾数部分为：<br>\n$$R_2+\\lfloor M/2 \\rfloor=R_2+M/2+1/2$$\n当$R_2+M/2+1/2<1$，有<br>\n$$\\begin{align}\n    y_0&=(1+R_2+\\lfloor M/2 \\rfloor)2^{R_1+\\lfloor E/2 \\rfloor-127} \\nonumber\\\\\n    &=(3+2R_2+M)2^{R_1+d-65} \\nonumber\n\\end{align}$$\n当$R_2+M/2+1/2\\ge1$，有<br>\n$$\\begin{align}\n    y_0&=(1+R_2+\\lfloor M/2 \\rfloor-1)2^{R_1+\\lfloor E/2 \\rfloor-127+1} \\nonumber\\\\\n    &=(2+4R_2+2M)2^{R_1+d-65} \\nonumber\n\\end{align}$$\n令<br>\n$$\\gamma=\\begin{cases}\n    2R_2+M & ,R_2+M/2<1/2 \\\\\n    4R_2+2M-1 & ,R_2+M/2\\ge1/2\n\\end{cases}$$\n则<br>\n$$y_0=(3+\\gamma)2^{R_1+d-65}$$\n则$y_0$和真实值之间的相对误差为：<br>\n$$\\epsilon=\\vert \\epsilon_1 \\vert=\\vert \\frac{y-y_0}{y} \\vert=\\vert 1-\\frac{3+\\gamma}{\\sqrt{1+M}}2^{R_1-65} \\vert$$\n令$M=1$，则<br>\n$$\\epsilon_1=1-(1+R_2)2^{R_1-63.5}$$\n令$\\vert \\epsilon_1 \\vert<1/8$，则<br>\n$$62.3=63.5+\\log_2{\\frac{7}{16}}<R_1<63.5+\\log_2{\\frac{9}{8}}=63.6$$\n所以$R_1=63=0x3F$，和$E$为偶数的情况一样<br>\n\n### 优化$R_2$的值\n根据论文中的说法，我们要寻找一个$R_2$，使得$\\max\\{\\vert \\epsilon_0 \\vert, \\vert \\epsilon_1 \\vert \\}$的值最小，接下来我们列出$\\epsilon_0$和$\\epsilon_1$在各分段上的最大值<br>\n对于$\\epsilon_0$：<br>\n① 当$M=0, R_2<1$<br>\n$$f_1(R_2)=1-1/\\sqrt{2}-R_2/\\sqrt{2}$$\n② 当$M=1$<br>\n$$f_2(R_2)=\\begin{cases}\n    1/4-R_2/2 & ,R_2<1/2 \\\\\n    1/2-R_2 & ,R_2\\ge1/2\n\\end{cases}$$\n③ 当$M=2-2R_2, R_2 \\in (\\frac{1}{2},1]$<br>\n$$f_3(R_2)=1-\\frac{\\sqrt{2}}{\\sqrt{3-2R_2}}$$\n④ 当$M<2-2R_2$，令$\\epsilon_0^{'}=0$得$M=2R_2, R_2\\in[0, \\frac{1}{2})$<br>\n$$f_4=1-\\frac{\\sqrt{1+2R_2}}{\\sqrt{2}}$$\n⑤ 当$M\\ge2-2R_2$，令$\\epsilon_0^{'}=0$得$M=2R_2-2, R_2=1$<br>\n$$f_5(R_2)=1-\\sqrt{2}\\sqrt{2R_2-1}$$\n对于$\\epsilon_1$：<br>\n⑥ 当$M=0$<br>\n$$f_6(R_2)=\\begin{cases}\n    1/4-R_2/2 & ,R_2<1/2 \\\\\n    1/2-R_2 & ,R_2\\ge1/2\n\\end{cases}$$\n⑦ 当$M=1$<br>\n$$f_7(R_2)=1-1/\\sqrt{2}-R_2/\\sqrt{2}$$\n⑧ 当$M=1-2R_2$，$R_2<\\frac{1}{2}$<br>\n$$f_8(R_2)=1-\\frac{1}{2-2R_2}$$\n⑨ 当$M<1-R_2$，令$\\epsilon_1^{'}=0$，得$M=2R_2+1$不存在，则最值在$M=0$或$M=1-2R_2$上<br>\n$$f_9(R_2)=\\epsilon_1|_{M=1-2R_2}=1-\\frac{1}{2-2R_2}, R_2<\\frac{1}{2}$$\n⑩ 当$M>1-2R_2$，令$\\epsilon_1^{'}=0$，得$M=2R_2-1$<br>\n$$f_{10}(R_2)=1-\\sqrt{2R_2},R_2>\\frac{1}{2}$$\n用matlab求$f_1 \\sim f_{10}$的最小值，得<br>\n$$\\min\\{f_i\\}=2.1925\\times10^{-6}$$\n此时$R_2$对应的小数值<br>\n$$r_0=0.4142$$\n$R_2$按位表示为<br>\n$$R_2=\\lfloor r_0 \\times 2^{23} \\rfloor=3474701=0x35050D$$\n结合易得到的$R_1$，于是<br>\n$$R=0x1FB5050D$$\n\n## 测试\n论文给出的这个方法计算魔法常数的$R_1$是没有问题的，但计算出的$R_2$不是最优的。在原论文的测试中，作者理论计算出的魔法常数在计算牛顿法迭代初值时优于卡马克的算法中的魔法常数，但在一次和两次迭代后其误差却大于原魔法常数。于是作者用暴力算法以原魔法常数为起点向两边搜索最佳常数，最后发现了比原常数和他自己计算出的常数更优的另一个常数，因缺思汀，但无从解释。<br>\n因此我对我计算出的魔法常数的$R_2$值也并不抱太大期待，我也以前面计算出的$R$为起点开始暴力搜索最佳参数，可是不知是我对原论文$R_2$的算法没理解透还是计算错误，我计算出的$R_2$明显与最佳值相去甚远，我的电脑跑了一个多星期还没到达最佳值，我只能手动将$R$试凑到离误差最小值相近的位置，再次进行暴力搜索，最终找到使牛顿法一次迭代后误差最小的$R$值：\n$$R=0x1FBB674C$$\n此时牛顿法一次迭代的最大误差约为$0.0601\\%$，两次迭代最大误差约为$2.54\\times10^{-7}$。于是最终的求$y=\\sqrt{x}$的代码如下：<br>\n```c\nfloat get_sqrt(float x)\n{\n    float x_temp = x;\n    int i = *(int*)&x;\n    i = 0x1fbb674c + (i>>1);\n    x = *(float*)&i;\n    x = 0.5f * (x + x_temp/x);\n    x = 0.5f * (x + x_temp/x);\n    return x;\n}\n```\n\n### 几种算法速度和误差的对比\n第一种算法就是前一节的get_sqrt()，第二种算法用卡马克的invSqrt()函数求解平方根倒数近似值后再求倒数，其代码如下：<br>\n```c\nfloat get_sqrt_by_inv_sqrt(float x)\n{\n    float x_temp = 0.5f * x;\n    int i = *(int*)&x;\n    i = 0x5f375a86 - (i>>1);\n    x = *(float*)&i;\n    x = x * (1.5f - x_temp * x * x);\n    x = x * (1.5f - x_temp * x * x);\n    x = 1/x;\n    return x;\n}\n```\n首先测试了get_sqrt()和get_sqrt_by_inv_sqrt()，两种方法求得的平方根的精度，在单精度浮点数域中跑，求最大相对误差，结果如下：<br>\n\n| 算法 |初值误差|一次迭代误差|两次迭代误差|\n| ---- | ----  | --------- | --------- |\n|get_sqrt()|0.03526|$6.01\\times 10^{-4}$|$2.54\\times 10^{-7}$|\n|get_sqrt_by_inv_sqrt()|0.03558|$1.754\\times 10^{-3}$|$4.775\\times 10^{-6}$|\n\n可以看到直接求解平方根的get_sqrt()函数，和先求解平方根倒数，再做一次倒数求解平方根的算法比较，直接求解的方法在精度上完虐后者。<br>\n接着测试速度，测试的算法有3种：get_sqrt()，get_sqrt_by_inv_sqrt()，以及直接用库函数sqrt()，在单精度浮点数域中跑，结果如下：<br>\n\n|算法|用时|\n|---|---|\n|get_sqrt()|10秒|\n|get_sqrt_by_inv_sqrt()|14秒|\n|sqrt()|4秒|\n\n这下尴尬了，虽然get_sqrt()比get_sqrt_by_inv_sqrt()快，但是捣鼓了半天速度还大大不如人家库函数的。可能在卡马克那个年代库函数还没那么优秀，那个时候这些个求平方根近似值的函数还有一些优势。经过网上搜索和查询手册，发现Intel汇编指令集中有一个sqrtss指令和一个rsqrtss指令，专门用于计算平方根以及平方根倒数，我猜想这大概就是库函数速度飞快的原因吧，于是我尝试写了一段内联汇编测试sqrtss指令的速度，发现同样条件下汇编代码用时6秒，比我自己写的代码快些，比库函数慢些，大概库函数还做了些优化吧。使用内联汇编的c代码如下<br>\n```c\nfloat get_sqrt_asm(float x)\n{\n    float y;\n    __asm(\n        \"movss %1, %%xmm0 \\n\"\n        \"sqrtss %%xmm0, %%xmm0 \\n\"\n        \"movss %%xmm0, %0 \\n\"\n        : \"=m\"(y)\n        : \"m\"(x)\n    );\n    return y;\n}\n```\n不知道在MCU、DSP这些嵌入式设备上，这些近似函数还有没有用武之地，以后有机会在测试吧，这次的测试就此打完收工。<br>","tags":["just4fun"]}]